pub extern crate tex;
extern crate wait_timeout;

use std::fs;
use std::process;
use std::env;
use std::path::PathBuf;
use std::io::prelude::*;
use std::time::Duration;
use self::wait_timeout::ChildExt;

pub use self::tex::parser;

pub mod format;
pub use format::*;

pub const OUTPUT_TEST_PATH: &'static str = "/tmp/tex-test/";
pub const INPUT_TEST_PATH: &'static str = "assets/";

// TODO: for the moment, test routine does only support Linux and maybe OSX.

macro_rules! test_tex {
    ($test_name: ident) => (
        #[test]
        fn $test_name() {
            use std::io::prelude::*;

            // Be sure that the output folder is created.
            std::fs::create_dir_all(OUTPUT_TEST_PATH).unwrap();

            // Get the path of the tex test file.
            // This path should be absolute.
            let mut tex_path = std::env::current_dir().unwrap();
            tex_path.push(INPUT_TEST_PATH);
            tex_path.push(stringify!($test_name));
            tex_path.set_extension("tex");
            let tex_path = std::fs::canonicalize(tex_path.as_path()).unwrap();
            let tex_path = tex_path.to_str().unwrap();

            // Read input file.
            let mut file = std::fs::File::open(tex_path).unwrap();
            let mut input = String::new();
            file.read_to_string(&mut input).unwrap();

            // Execute parser.
            let mut parser = common::parser::Parser::new(&input);
            let result = parser.parse().unwrap();

            // Create the output path for the newly parser and formatted
            // tex document.
            let mut output_path = std::path::PathBuf::from(OUTPUT_TEST_PATH);
            output_path.push(concat!(stringify!($test_name), "-test"));
            output_path.set_extension("tex");
            let output_path = output_path.to_str().unwrap();

            // Write the parser's output in a file to compile it with `tex`.
            let mut output_file = std::fs::File::create(output_path).unwrap();
            let formatted_output = common::format(result);
            output_file.write(formatted_output.as_bytes()).unwrap();

            // Print the formatted output to easily compare the parser TeX.
            println!("{}", formatted_output);

            // Test!
            let test_filename = stringify!($test_name);
            let parsed_output_filename = concat!(stringify!($test_name), "-test");
            assert_eq!(common::get_tex_output(INPUT_TEST_PATH, test_filename),
                       common::get_tex_output(OUTPUT_TEST_PATH, parsed_output_filename));
        }
    )
}

// Also makes TeX output reproducible by removing the first header
// line which contains the date of the compilation.
pub fn get_tex_output(dir: &str, filename: &str) -> Vec<u8> {
    let mut file_path = env::current_dir().unwrap();
    file_path.push(dir);
    file_path.push(filename);
    let file_path = file_path.to_str().unwrap();

    let mut child = process::Command::new("tex")
        .args(&[file_path])
        .current_dir(OUTPUT_TEST_PATH)
        .stdout(process::Stdio::null())
        .spawn()
        .expect("Can't execute tex");

    match child.wait_timeout(Duration::from_secs(2)).unwrap() {
        Some(status) => assert!(status.success()),
        None => {
            child.kill().unwrap();
        }
    };

    // assert!(status.success());

    let mut output_path = PathBuf::from(OUTPUT_TEST_PATH);
    output_path.push(filename);
    output_path.set_extension("dvi");

    let mut output_file = fs::File::open(output_path.to_str().unwrap()).unwrap();
    let mut buffer = vec![];

    output_file.read_to_end(&mut buffer).unwrap();

    make_tex_output_reproducible(buffer)
}

// The basic idea is to remove the first line of the DVI as it's just an
// header which is autogenerated with the compilation date which makes
// 2 DVI output incomparables.
fn make_tex_output_reproducible(output: Vec<u8>) -> Vec<u8> {
    output
        .into_iter()
        .skip_while(|x| *x != ('\n' as u8))
        .skip(1)
        .collect()
}
